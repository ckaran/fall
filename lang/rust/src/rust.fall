tokenizer {
  #[skip] whitespace r"\s+"
  #[skip] line_comment r"//.*\n?"

  #[contextual] union 'union'
  as 'as'
  crate 'crate'
  extern 'extern'
  fn 'fn'
  let 'let'
  pub 'pub'
  struct 'struct'
  use 'use'
  mod 'mod'
  if 'if'
  else 'else'
  enum 'enum'
  impl 'impl'
  self 'self'
  super 'super'
  type 'type'
  const 'const'
  static 'static'
  for 'for'
  loop 'loop'
  while 'while'
  move 'move'
  mut 'mut'
  ref 'ref'
  trait 'trait'
  match 'match'
  return 'return'
  in 'in'

  l_paren '('
  r_paren ')'
  l_curly '{'
  r_curly '}'
  l_angle '<'
  r_angle '>'
  l_brack '['
  r_brack ']'
  #[contextual] shl '<<'
  #[contextual] shr '>>'
  #[contextual] and '&&'
  #[contextual] or  '||'
  thin_arrow '->'
  fat_arrow '=>'
  eq '='
  eqeq '=='
  bangeq '!='
  gtet '>='
  lteq '<='
  semi ';'
  colon ':'
  coloncolon '::'
  comma ','
  dot '.'
  dotdot '..'
  hash '#'

  star '*'
  slash '/'
  percent '%'
  plus '+'
  minus '-'
  ampersand '&'
  pipe '|'
  underscore '_'
  bang '!'

  lifetime r"'\p{XID_Continue}*"
  ident r"\p{XID_Start}\w*"
  number r"\d+"
  string r#""([^"]|\\")*""#
  raw_string r#"r#*""# 'parse_raw_string'
}

pub rule file { mod_contents }

rule mod_contents {
  <with_skip mod_form_first mod_form>*
}

rule mod_form_first { 
  'struct' | 'union' | 'enum' | 'use' | 'mod' 
| 'impl' | 'trait'
| impl_form_first
}

rule mod_form { 
  use_decl | extern_crate_decl | fn_def | struct_def | enum_def | mod_def 
| impl_def | trait_def | type_def | const_def
| extern_block
}

pub rule use_decl {
  outer_attributes visibility? 'use' <commit> { 
    mod_path {alias | {'::' use_spec}?}
  | '::'? use_spec 
  } ';'
}

pub rule use_spec {
  '*'
| <block <comma_list use_spec_entry>> 
}

pub rule use_spec_entry {
  ident <commit> alias?
}

pub rule extern_crate_decl {
  outer_attributes visibility? 'extern' 'crate' <commit> ident alias? ';'
}

pub rule fn_def {
  outer_attributes visibility? linkage? 'fn' <commit> ident
  type_parameters?
  value_parameters
  ret_type?
  {block_expr | ';'}
}

test r"
fn foo(&mut self: Box<Self>, x: i32) -> () {
  ()
}
"

rule ret_type {
  '->' type_reference
}

pub rule linkage { 
  'extern' string?
}

rule value_parameters {
  <in_parens {self_parameter? <comma_list value_param>}>
}

pub rule value_param {
  pattern <commit> ':' type_reference
}

pub rule lambda_value_param {
  pattern {':' type_reference}?
}

pub rule self_parameter {
  '&'? 'mut'? 'self' <commit> {':' type_reference}? {',' | <eof>}
}

pub rule struct_def {
  outer_attributes visibility?
  {'struct' | 'union'} <commit> 
  ident type_parameters? {
    <block <comma_list struct_field>>
  | ';'
  | <in_parens <comma_list tuple_field>>';'
  }
}

pub rule struct_field {
  visibility? ident <commit> ':' type_reference
}

pub rule tuple_field {
  visibility? type_reference
}

pub rule enum_def {
  outer_attributes visibility? 'enum' <commit> ident
  <block <comma_list enum_variant>>
}

pub rule enum_variant {
  ident <commit> 
  { '=' expr
  | <in_parens <comma_list tuple_field>>
  | <block <comma_list struct_field>>
  }?
}

pub rule mod_def {
  outer_attributes visibility? 'mod' <commit> 
  ident { ';' | <block mod_contents> }
}

pub rule impl_def {
  outer_attributes 'impl' <commit> 
  type_parameters?
  {type_reference {'for' type_reference}? }
  members
}

test r"
impl Node {}
impl<'f> ::Debug for Node<'f> { }
"

pub rule trait_def {
  outer_attributes visibility? 'trait' <commit>
  ident type_parameters?
  members
}

test r"
pub trait T<X> {}
"

pub rule members {
  <block <with_skip impl_form_first impl_form>*>
}


rule impl_form {
  fn_def | type_def
}

rule impl_form_first {
  'pub' | 'fn' | 'type' | 'const' | 'static'
| '#' | 'extern'
}

pub rule type_def {
  outer_attributes visibility? 'type' <commit> 
  ident type_parameters?
  {'=' type_reference}?
  ';'
}

pub rule const_def {
  outer_attributes visibility? {'const' | 'static'} <commit>
  ident ':' type_reference
  {'=' expr}? ';'
}

test r"
pub const X: i32 = 0;
"

pub rule extern_block {
  linkage <block extern_form*>
}

rule extern_form {
  fn_def | const_def
}

test r"
extern {
  static errno: i32;
  fn foo();
}
"

pub rule type_parameters {
  <in_angles {
    <comma_list lifetime_parameter>
    <comma_list type_parameter>
  }>
}

test r"
struct B<'b, C>();
"

pub rule type_parameter {
  ident
}

pub rule lifetime_parameter {
  lifetime
}

pub rule visibility {
  'pub'
}

rule mod_path { path }
rule type_path { <enter 'type_path' path> }
rule expr_path { <enter 'expr_path' path> }

test r"
const C: Foo<Bar> = foo::<'bar, Baz>;
"

#[pratt]
pub rule path {
  unqualified_path | qualified_path
}

#[atom, type(path)]
pub rule unqualified_path {
  '::'? path_segment
}

#[postfix, type(path)]
pub rule qualified_path {
  path {'::' path_segment}
}

rule path_segment {
  { ident | 'self' | 'super' } type_arguments?
}

pub rule type_arguments {
  { <is_in 'type_path'> | <is_in 'expr_path'> '::' }
  <in_angles {
    <comma_list lifetime>
    <comma_list type_reference>
  }> 
}


pub rule alias { 'as' ident }

// START TYPES

rule type_reference {
  path_type | reference_type 
| placeholder_type | unit_type | paren_type
| array_type
| fn_pointer_type
}

pub rule path_type {
  type_path
}
test r"type T = X<Foo, Bar>;"

pub rule reference_type {
  '&' lifetime?  'mut'? type_reference
}
test r"type T = &'static mut X;"


pub rule placeholder_type {
  '_'
}
test r"type T = _;"

pub rule unit_type {
  '(' ')'
}

#[replaceable]
pub rule paren_type {
  <in_parens {type_reference tuple_type?}>
}

#[replaces]
pub rule tuple_type { 
  ',' <comma_list type_reference>
}

test r"
type T = ();
type T = (A);
type T = (A,);
type T = (A, B);
"

pub rule array_type {
  <in_bracks {
    type_reference {';' expr}?
  }>
}
test r"
type T = [(); 92];
type T = &[()];
"

pub rule fn_pointer_type {
  'fn' <commit> <in_parens <comma_list anon_value_param>> ret_type
}

#[type(value_param)]
pub rule anon_value_param {
  {pattern ':'}? type_reference
}

test r"
type F = fn(i32, x: f64) -> ();
"

// END TYPES

// START PATTERNS

rule pattern {
  wildcard_pattern | path_pattern
| binding_pattern | literal_pattern | unit_pattern | paren_pattern
| reference_pattern
}

pub rule wildcard_pattern {
  '_'
}
test r"fn main() { let _ = (); }"


#[replaceable]
pub rule path_pattern {
  expr_path {tupe_struct_pattern | struct_pattern}?
}

#[replaces]
pub rule tupe_struct_pattern {
  <in_parens {
    <comma_list pattern> {'..' ','?}?
  }>
}

#[replaces]
pub rule struct_pattern {
  <block {
    <comma_list struct_pattern_field> {'..' ','?}?
  }>
}

pub rule struct_pattern_field {
  binding_pattern <not ':'>
| ident ':' <commit> pattern
}

test r"
fn main() { 
  let foo::bar = (); 
  let S(foo, bar, .. ,) = ();
  let foo::Bar { ref x, y: _, .. } = ();
}"


pub rule binding_pattern {
  'ref'? 'mut'? ident
}
test r"
fn main() {
    let foo = ();
    let ref mut bar = 92;
}
"

pub rule literal_pattern {
  literal
}

pub rule unit_pattern {
  '(' ')'
}

#[replaceable]
pub rule paren_pattern {
  <in_parens {pattern tuple_pattern?}>
}

#[replaces]
pub rule tuple_pattern {
  ',' <comma_list pattern>
}

test r"
fn main() {
  let (x) = ();
  let (x,) = ();
  let (x, y) = ();
  let () = ();
}
"

pub rule reference_pattern {
  '&' 'mut'? pattern
}

test r"
fn main() { let &mut foo = bar; }
"

// END PATTERNS

// START EXPRESSIONS

#[pratt]
pub rule expr { 
  literal | path_expr | unit_expr | paren_expr 
| lambda_expr | return_expr
| block_expr | if_expr | while_expr | loop_expr | for_expr | match_expr
| block_macro_expr | line_macro_expr

| method_call_expr | call_expr | field_expr | index_expr

| reference_expr | dereference_expr | negation_expr

| product_expr | sum_expr 
| bit_shift
| bit_and | bit_or
| comparison 	
| logical_and | logical_or
}

rule prev_is_block {
  <prev_is block_expr if_expr while_expr loop_expr for_expr match_expr
    block_macro_expr
  >
}

rule without_restrictions(p) {
  <exit 'condition' <exit 'stmt' p>>
}

#[atom]
pub rule literal {
  number | string | raw_string
}

test r###"
fn main() {
  (1, "", r"")
}
"###

#[atom, replaceable]
pub rule path_expr {
  <not {ident '!'}>
  expr_path struct_literal?
}

#[replaces]
pub rule struct_literal {
  <not <is_in 'condition'>>
  <block <comma_list struct_literal_field>>
}

pub rule struct_literal_field {
  ident <commit> ':' expr
}

#[atom]
pub rule unit_expr { '(' ')' }

#[atom, replaceable]
pub rule paren_expr {
  <in_parens {
    <without_restrictions expr> tuple_expr?
  }>
}

#[replaces]
pub rule tuple_expr {
  ',' <comma_list <without_restrictions expr>>
}

test r"
fn main() {
  ();
  (1);
  ((1));
  (1,);
  (1, 2);
}
"

#[atom]
pub rule lambda_expr {
  'move'? '|' lambda_arg* '|' {
    '->' type_reference block_expr
  | <without_restrictions expr>
  }
}

rule lambda_arg {
  lambda_value_param <commit> {',' | <not <not '|'>>} 
}

test r"
fn foo() { 
    |x, y: i32,| 1 + 1;
    move || -> i32 { 92 };
}
"

test r"
fn binary_or_lambda_ambiguity() {
    || true || false;
}
"

#[atom]
pub rule return_expr {
  'return' expr?
}

test r"
fn main() { return; return (); }
"


#[atom]
pub rule block_expr {
  <without_restrictions
    <block {block_form* expr?}>
  >
}

rule block_form {
  let_stmt | expr_stmt | empty_stmt | mod_form
}

pub rule let_stmt {
  'let' <commit> pattern '=' expr ';'
}

pub rule empty_stmt { ';' }

pub rule expr_stmt {
  <enter 'stmt'
    {expr {prev_is_block <not <eof>> | ';'}}
  >
}

#[atom]
pub rule if_expr {
  'if' <commit>  
    block_condition block_expr 
    {'else' block_expr}?
}

test r"
fn main() { if true { foo } else { bar } }
"

#[atom]
pub rule while_expr {
  label? 'while' <commit>  
    block_condition block_expr 
    }

test r"
fn main() { 'w: while true {} }
"    

rule block_condition {
  {'let' <commit> pattern '='}? no_struct_literal_expr 
}

rule no_struct_literal_expr {
  <enter 'condition' expr>
}

test r"
fn main() {
    if S {};
    if (S {}) {}
    if let Some(x) = foo() {}
}
"

#[atom]
pub rule loop_expr {
  label? 'loop' <commit> block_expr
}

test r"
fn main() { 'pool: loop { 92 }}
"

#[atom]
pub rule for_expr {
  label? 'for' <commit> 
  pattern 'in' no_struct_literal_expr block_expr
}

rule label {
  lifetime ':'
}

test r"
fn main() { for x in xs {} }
"

#[atom]
pub rule match_expr {
  'match' <commit> no_struct_literal_expr <block match_arm*>
}

pub rule match_arm {
  match_arm_pattern <commit> 
  '=>' expr 
  {',' | <eof> | prev_is_block}
}

rule match_arm_pattern {
  pattern {'|' pattern}* guard?
}

pub rule guard { 
  'if' expr
}

test r"
fn main() {
    match x {
      Some(1) | Some(2) => { no_comma }
      Some(x) if x & 3 => true,
      None => false,
    }
}
"

#[atom]
pub rule block_macro_expr {
  block_macro
}

#[atom]
pub rule line_macro_expr {
  line_macro
}

test r#"
fn main() {
    block! {
      foo => bar
    }
    println!("Hello, world");
    vec![]
}
"#

#[postfix]
pub rule method_call_expr {
  expr { 
    '.' ident <enter 'expr_path' type_arguments>?
    call_args   
  }
}

test r"
  fn main() { foo.bar::<i32>() }
"

#[postfix]
pub rule call_expr {
  expr call_args
}

rule call_args {
  <without_restrictions <in_parens <comma_list value_argument>>>
}

test r"
  fn main() { foo() }
"


#[postfix]
pub rule field_expr {
  expr {'.' {ident | number}}
}
test r"
fn main() { x.foo; x.92; }
"

#[postfix]
pub rule index_expr {
  expr <in_bracks expr>
}
test r"
fn main() { xs[92]; }
"

pub rule value_argument {
  expr
}

#[prefix]
pub rule reference_expr { '&' expr }

#[prefix]
pub rule dereference_expr { '*' expr }

#[prefix]
pub rule negation_expr { '-' expr }

#[bin(8)]
pub rule product_expr {
  expr <binop {'*' | '/' | '%'}> expr
}

#[bin(7)]
pub rule sum_expr {
  expr <binop {'+' | '-'}> expr
}

#[bin(6)]
pub rule bit_shift {
  expr <binop {'<<' | '>>'}> expr
}

rule binop(op) {
  <is_in 'stmt'> <not prev_is_block> op
| <not <is_in 'stmt'>> op
}

#[bin(5)]
pub rule bit_and {
  expr <binop {'&' <not '&'>}> expr
}

#[bin(4)]
pub rule bit_or {
  expr <binop {'|' <not '|'>}> expr
}

#[bin(3)]
pub rule comparison {
  expr <binop cmp_op> expr
}

rule cmp_op {
  '==' | '!=' | '<' | '>' | '<=' | '>='
}

#[bin(2)]
pub rule logical_and {
  expr <binop '&&'> expr
}

#[bin(1)]
pub rule logical_or {
  expr <binop '||'> expr
}

// END EXPRESSIONS

// STATART ATRIBUTES

pub rule attribute {
  '#' <in_bracks <comma_list attr_value>>
}

test r#"
#[foo, bar(baz), quux = 92] struct Foo;
#[cfg(target_os="linux")] mod bar;
"#

rule outer_attributes {
  attribute*
}

pub rule attr_value {
  ident <commit> 
  { '=' expr 
  | <in_parens <comma_list attr_value>>
  }?
}

// END ATRIBUTES

// START MACROS

pub rule block_macro {
  ident '!' ident? <block tt*>
}

pub rule line_macro {
  ident '!' ident? {
    '(' tt* ')' 
  | '[' tt* ']'
  }
}

pub rule tt {
  <not {'(' | ')' | '{' | '}' | '[' | ']'}> <any>
| '(' tt* ')'
| '[' tt* ']'
| '{' tt* '}'
}

// END MACROS

// START HELPERS

rule comma_list(el) {
  {el <commit> {<eof> | ','}}*
}

rule block(p)     { <balanced_layer '{' '}' p> }
rule in_parens(p) { <balanced_layer '(' ')' p> }
rule in_angles(p) { <balanced_layer '<' '>' p> }
rule in_bracks(p) { <balanced_layer '[' ']' p> }

rule balanced_layer(bra, ket, contents) {
  bra <commit> 
    <layer <balanced bra ket> contents> 
  ket
}

rule balanced(bra, ket) {
  { bra <commit> <balanced bra ket> ket
  | {<not ket> <any>}
  }*
}

// END HELPERS

verbatim r##########"
fn whitespace_binder(ty: NodeType, adjacent_tokens: Vec<(NodeType, &str)>, is_leading: bool) -> usize {
    if !is_leading {
        return 0;
    }
    match ty {
        STRUCT_DEF => {
            let mut has_comment = false;
            adjacent_tokens.iter().rev()
                .take_while(|&&(ty, text)| {
                    if ty == LINE_COMMENT {
                        has_comment = true;
                        true
                    } else {
                        ty == WHITESPACE && text.chars().filter(|&c| c == '\n').next().is_none()
                    }
                })
                .count()
        }
        _ => 0,
    }
}

fn parse_raw_string(s: &str) -> Option<usize> {
    let quote_start = s.find('"').unwrap();
    // Who needs more then 25 hashes anyway? :)
    let q_hashes = concat!('"', "######", "######", "######", "######", "######");
    let closing = &q_hashes[..quote_start];
    s[quote_start + 1..].find(closing).map(|i| i + quote_start + 1 + closing.len())
}
"##########
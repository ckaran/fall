tokenizer {
  #[skip] whitespace r"\s+"

  as 'as'
  crate 'crate'
  extern 'extern'
  fn 'fn'
  let 'let'
  pub 'pub'
  struct 'struct'
  use 'use'
  mod 'mod'

  lparen '('
  rparen ')'
  lbrace '{'
  rbrace '}'
  langle '<'
  rangle '>'
  thin_arrow '->'
  eq '='
  semi ';'
  colon ':'
  coloncolon '::'
  comma ','

  plus '+'
  minus '-'
  star '*'
  slash '/'
  percent '%'

  ident r"\p{XID_Start}\w*"
  number r"\d+"
}

pub rule file { mod_contents }

rule mod_contents {
  <rep <with_skip mod_form_first mod_form>>
}


rule mod_form_first { 
  'pub' | 'fn' | 'struct' | 'use' | 'extern' | 'mod'
}

rule mod_form { 
  use_decl | extern_crate_decl | fn_def | struct_def | mod_def
}

pub rule use_decl {
  'use' <commit> { 
    mod_path {alias | <opt {'::' use_spec}>}
  | <opt '::'> use_spec 
  } ';'
}

pub rule use_spec {
  '*'
| <block <comma_list use_spec_entry>> 
}

pub rule use_spec_entry {
  ident <commit> <opt alias>
}

pub rule extern_crate_decl {
  'extern' 'crate' <commit> ident <opt alias> ';'
}

pub rule fn_def {
  <opt visibility> 'fn' <commit> ident
  value_params
  <opt {'->' type}>
  block_expr
}

rule value_params {
  <in_parens <comma_list value_param>>
}

pub rule value_param {
  pattern ':' type
}


pub rule struct_def {
  <opt visibility> 'struct' <commit> ident {
    <block <comma_list struct_field>>
  | ';'
  | <in_parens <comma_list tuple_field>>';'
  }
}

pub rule mod_def {
  <opt visibility> 'mod' <commit> ident {
    ';'
  | <block mod_contents>
  }
}

pub rule struct_field {
  <opt visibility> ident <commit> ':' type
}

pub rule tuple_field {
  <opt visibility> type
}

pub rule visibility {
  'pub'
}

rule mod_path { path }
rule type_path { <enter 'type_path' path> }
rule expr_path { <enter 'expr_path' path> }

#[pratt]
pub rule path {
  unqualified_path | qualified_path
}

#[atom, type(path)]
pub rule unqualified_path {
  <opt '::'> path_segment
}

#[postfix, type(path)]
pub rule qualified_path {
  path {'::' path_segment}
}

rule path_segment {
  ident <opt type_arguments>
}

pub rule type_arguments {
  { <is_in 'type_path'> | <is_in 'expr_path'> '::' }
  <in_angles <comma_list type>> 
}


pub rule alias { 'as' ident }

pub rule type {
  type_path
}

pub rule pattern { ident }

#[pratt]
pub rule expr { 
   sum_expr | product_expr 
|  literal | path_expr | block_expr
}

example r"
  fn foo() {
    let x = 1 + 2 * 92 + 3 % 8;
  }
"

#[bin(2)]
pub rule product_expr {
  expr {'*' | '/' | '%'} expr
}

#[bin(1)]
pub rule sum_expr {
  expr {'+' | '-'} expr
}

#[atom]
pub rule literal {
  number
}

#[atom]
pub rule path_expr {
  expr_path
}

#[atom]
pub rule block_expr {
  <block {<rep block_form> <opt expr>}>
}

rule block_form {
  let_stmt | expr_stmt
}

pub rule let_stmt {
  'let' <commit> pattern '=' expr ';'
}

pub rule expr_stmt {
  expr ';'
}

rule comma_list(el) {
  <rep {el <commit> {<eof>|','}}>
}

rule block(p)     { <balanced_layer '{' '}' p> }
rule in_parens(p) { <balanced_layer '(' ')' p> }
rule in_angles(p) { <balanced_layer '<' '>' p> }

rule balanced_layer(bra, ket, contents) {
  bra <commit> 
    <layer <balanced bra ket> contents> 
  ket
}

rule balanced(bra, ket) {
  <rep {
    bra <commit> <balanced bra ket> ket
  | <not ket> 
  }>
}

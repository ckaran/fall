tokenizer {
  #[skip] whitespace r"\s+"

  #[contextual] union 'union'
  as 'as'
  crate 'crate'
  extern 'extern'
  fn 'fn'
  let 'let'
  pub 'pub'
  struct 'struct'
  use 'use'
  mod 'mod'
  if 'if'
  else 'else'
  enum 'enum'
  impl 'impl'
  self 'self'
  super 'super'
  type 'type'
  const 'const'
  for 'for'
  loop 'loop'
  while 'while'
  move 'move'
  mut 'mut'
  ref 'ref'
  trait 'trait'

  l_paren '('
  r_paren ')'
  l_curly '{'
  r_curly '}'
  l_angle '<'
  r_angle '>'
  l_brack '['
  r_brack ']'
  #[contextual] shl '<<'
  #[contextual] shr '>>'
  #[contextual] and '&&'
  #[contextual] or  '||'
  thin_arrow '->'
  eq '='
  semi ';'
  colon ':'
  coloncolon '::'
  comma ','
  dot '.'
  hash '#'

  star '*'
  slash '/'
  percent '%'
  plus '+'
  minus '-'
  ampersand '&'
  pipe '|'
  underscore '_'

  lifetime r"'\p{XID_Continue}*"
  ident r"\p{XID_Start}\w*"
  number r"\d+"
  string r#""([^"]|\\")*""#
}

pub rule file { mod_contents }

rule mod_contents {
  <with_skip mod_form_first mod_form>*
}


rule mod_form_first { 
  'pub' | 'extern' | '#'
| 'fn' | 'struct' | 'union' | 'enum' | 'use' | 'mod' 
| 'impl' | 'trait' | 'type'
| 'const'
}

rule mod_form { 
  use_decl | extern_crate_decl | fn_def | struct_def | enum_def | mod_def 
| impl_def | trait_def | type_def | const_def
}

pub rule use_decl {
  outer_attributes visibility? 'use' <commit> { 
    mod_path {alias | {'::' use_spec}?}
  | '::'? use_spec 
  } ';'
}

pub rule use_spec {
  '*'
| <block <comma_list use_spec_entry>> 
}

pub rule use_spec_entry {
  ident <commit> alias?
}

pub rule extern_crate_decl {
  outer_attributes 'extern' 'crate' <commit> ident alias? ';'
}

pub rule fn_def {
  outer_attributes visibility? 'fn' <commit> ident
  type_parameters?
  value_parameters
  {'->' type_reference}?
  block_expr
}

rule value_parameters {
  <in_parens {self_parameter? <comma_list value_param>}>
}

pub rule value_param {
  pattern <commit> ':' type_reference
}

pub rule lambda_value_param {
  pattern {':' type_reference}?
}

pub rule self_parameter {
  '&'? 'self' <commit> {',' | <eof>}
}

pub rule struct_def {
  outer_attributes visibility?
  {'struct' | 'union'} <commit> 
  ident type_parameters? {
    <block <comma_list struct_field>>
  | ';'
  | <in_parens <comma_list tuple_field>>';'
  }
}

pub rule struct_field {
  visibility? ident <commit> ':' type_reference
}

pub rule tuple_field {
  visibility? type_reference
}

pub rule enum_def {
  outer_attributes visibility? 'enum' <commit> ident
  <block <comma_list enum_variant>>
}

pub rule enum_variant {
  ident <commit> 
  { '=' expr
  | <in_parens <comma_list tuple_field>>
  | <block <comma_list struct_field>>
  }?
}

pub rule mod_def {
  outer_attributes visibility? 'mod' <commit> 
  ident { ';' | <block mod_contents> }
}

pub rule impl_def {
  outer_attributes 'impl' <commit> 
  type_parameters?
  {type_reference {'for' type_reference}? }
  members
}

test r"
impl Node {}
impl<'f> ::Debug for Node<'f> { }
"

pub rule trait_def {
  outer_attributes visibility? 'trait' <commit>
  ident type_parameters?
  members
}

test r"
pub trait T<X> {}
"

pub rule members {
  <block <with_skip impl_form_first impl_form>*>
}


rule impl_form {
  fn_def | type_def
}

rule impl_form_first {
  'pub' | 'fn' | 'type'
}

pub rule type_def {
  outer_attributes visibility? 'type' <commit> 
  ident type_parameters?
  {'=' type_reference}?
  ';'
}

pub rule const_def {
  outer_attributes visibility? 'const' <commit>
  ident ':' type_reference
  '=' expr ';'
}

test r"
pub const X: i32 = 0;
"

pub rule type_parameters {
  <in_angles {
    <comma_list lifetime_parameter>
    <comma_list type_parameter>
  }>
}

test r"
struct B<'b, C>();
"

pub rule type_parameter {
  ident
}

pub rule lifetime_parameter {
  lifetime
}

pub rule visibility {
  'pub'
}

rule mod_path { path }
rule type_path { <enter 'type_path' path> }
rule expr_path { <enter 'expr_path' path> }

test r"
const C: Foo<Bar> = foo::<'bar, Baz>;
"

#[pratt]
pub rule path {
  unqualified_path | qualified_path
}

#[atom, type(path)]
pub rule unqualified_path {
  '::'? path_segment
}

#[postfix, type(path)]
pub rule qualified_path {
  path {'::' path_segment}
}

rule path_segment {
  { ident | 'self' | 'super' } type_arguments?
}

pub rule type_arguments {
  { <is_in 'type_path'> | <is_in 'expr_path'> '::' }
  <in_angles {
    <comma_list lifetime>
    <comma_list type_reference>
  }> 
}


pub rule alias { 'as' ident }

rule type_reference {
  path_type | reference_type 
| placeholder_type | unit_type | paren_type
| array_type
}

pub rule path_type {
  type_path
}
test r"type T = X<Foo, Bar>;"

pub rule reference_type {
  '&' lifetime?  'mut'? type_reference
}
test r"type T = &'static mut X;"


pub rule placeholder_type {
  '_'
}
test r"type T = _;"

pub rule unit_type {
  '(' ')'
}

#[replaceable]
pub rule paren_type {
  <in_parens {type_reference tuple_type?}>
}

#[replaces]
pub rule tuple_type { 
  ',' <comma_list type_reference>
}

test r"
type T = ();
type T = (A);
type T = (A,);
type T = (A, B);
"

pub rule array_type {
  <in_bracks {
    type_reference {';' expr}?
  }>
}
test r"
type T = [(); 92];
type T = &[()];
"


rule pattern {
  wildcard_pattern | tupe_struct_pattern | path_pattern
| binding_pattern 
}

pub rule wildcard_pattern {
  '_'
}
test r"fn main() { let _ = (); }"

pub rule tupe_struct_pattern {
  expr_path <in_parens <comma_list pattern>>
}
test r"fn main() { let S(foo, bar) = (); }"

pub rule binding_pattern {
  'ref'? 'mut'? ident
}
test r"
fn main() {
    let foo = ();
    let ref mut bar = 92;
}
"

pub rule path_pattern {
  expr_path
}
test r"fn main() { let foo::bar = (); }"

#[pratt]
pub rule expr { 
  literal | struct_literal | path_expr | unit_expr | paren_expr 
| lambda_expr | block_expr | if_expr | while_expr | loop_expr
| call_expr | field_expr | index_expr
| reference_expr | dereference_expr | negation_expr
| product_expr | sum_expr 
| bit_shift
| bit_and | bit_or
| logical_and | logical_or
}

rule prev_is_block {
  <prev_is if_expr block_expr>
}

rule without_restrictions(p) {
  <exit 'condition' <exit 'stmt' p>>
}

#[atom]
pub rule literal {
  number | string
}

#[atom]
pub rule struct_literal {
  <not <is_in 'condition'>>
  expr_path <block <comma_list struct_literal_field>>
}

pub rule struct_literal_field {
  ident <commit> ':' expr
}


#[atom]
pub rule path_expr {
  expr_path
}

#[atom]
pub rule unit_expr { '(' ')' }

#[atom, replaceable]
pub rule paren_expr {
  '(' <without_restrictions expr> tuple_expr? ')'
}

#[replaces]
pub rule tuple_expr {
  ',' <comma_list <without_restrictions expr>>
}

test r"
fn main() {
  ();
  (1);
  ((1));
  (1,);
}
"

#[atom]
pub rule lambda_expr {
  'move'? '|' lambda_arg* '|' {
    '->' type_reference block_expr
  | <without_restrictions expr>
  }
}

rule lambda_arg {
  lambda_value_param <commit> {',' | <not <not '|'>>} 
}

test r"
fn foo() { 
    |x, y: i32,| 1 + 1;
    move || -> i32 { 92 };
}
"

test r"
fn binary_or_lambda_ambiguity() {
    || true || false;
}
"

#[atom]
pub rule block_expr {
  <without_restrictions
    <block {block_form* expr?}>
  >
}

rule block_form {
  let_stmt | expr_stmt | empty_stmt
}

pub rule let_stmt {
  'let' <commit> pattern '=' expr ';'
}

pub rule empty_stmt { ';' }

pub rule expr_stmt {
  <enter 'stmt'
    {expr {prev_is_block <not <eof>> | ';'}}
  >
}

#[atom]
pub rule if_expr {
  'if' <commit>  
    block_condition block_expr 
    {'else' block_expr}?
}

test r"
fn main() { if true { foo } else { bar } }
"

#[atom]
pub rule while_expr {
  {lifetime ':'}? 'while' <commit>  
    block_condition block_expr 
    }

test r"
fn main() { 'w: while true {} }
"    

rule block_condition {
  <enter 'condition' {
    {'let' <commit> pattern '='}? expr 
  }>
}
test r"
fn main() {
    if S {};
    if (S {}) {}
    if let Some(x) = foo() {}
}
"

#[atom]
pub rule loop_expr {
  {lifetime ':'}? 'loop' <commit> block_expr
}

test r"
fn main() { 'pool: loop { 92 }}
"

#[postfix]
pub rule call_expr {
  expr <without_restrictions
    <in_parens <comma_list value_argument>>>
}

#[postfix]
pub rule field_expr {
  expr {'.' {ident | number}}
}
test r"
fn main() { x.foo; x.92; }
"

#[postfix]
pub rule index_expr {
  expr <in_bracks expr>
}
test r"
fn main() { xs[92]; }
"

pub rule value_argument {
  expr
}

#[prefix]
pub rule reference_expr { '&' expr }

#[prefix]
pub rule dereference_expr { '*' expr }

#[prefix]
pub rule negation_expr { '-' expr }

#[bin(7)]
pub rule product_expr {
  expr <binop {'*' | '/' | '%'}> expr
}

#[bin(6)]
pub rule sum_expr {
  expr <binop {'+' | '-'}> expr
}

#[bin(5)]
pub rule bit_shift {
  expr <binop {'<<' | '>>'}> expr
}

rule binop(op) {
  <is_in 'stmt'> <not prev_is_block> op
| <not <is_in 'stmt'>> op
}

#[bin(4)]
pub rule bit_and {
  expr <binop {'&' <not '&'>}> expr
}

#[bin(3)]
pub rule bit_or {
  expr <binop {'|' <not '|'>}> expr
}

#[bin(2)]
pub rule logical_and {
  expr <binop '&&'> expr
}

#[bin(1)]
pub rule logical_or {
  expr <binop '||'> expr
}

// Attributes

pub rule attribute {
  '#' <in_bracks <comma_list attr_value>>
}

test r#"
#[foo, bar(baz), quux = 92] struct Foo;
#[cfg(target_os="linux")] mod bar;
"#

rule outer_attributes {
  attribute*
}

pub rule attr_value {
  ident <commit> 
  { '=' expr 
  | <in_parens <comma_list attr_value>>
  }?
}

// Helper rules

rule comma_list(el) {
  {el <commit> {<eof> | ','}}*
}

rule block(p)     { <balanced_layer '{' '}' p> }
rule in_parens(p) { <balanced_layer '(' ')' p> }
rule in_angles(p) { <balanced_layer '<' '>' p> }
rule in_bracks(p) { <balanced_layer '[' ']' p> }

rule balanced_layer(bra, ket, contents) {
  bra <commit> 
    <layer <balanced bra ket> contents> 
  ket
}

rule balanced(bra, ket) {
  { bra <commit> <balanced bra ket> ket
  | {<not ket> <any>}
  }*
}

tokenizer {
  #[skip] whitespace r"\s+"

  #[contextual] union 'union'
  as 'as'
  crate 'crate'
  extern 'extern'
  fn 'fn'
  let 'let'
  pub 'pub'
  struct 'struct'
  use 'use'
  mod 'mod'
  if 'if'
  else 'else'
  enum 'enum'
  impl 'impl'
  self 'self'
  super 'super'
  type 'type'

  lparen '('
  rparen ')'
  lbrace '{'
  rbrace '}'
  langle '<'
  rangle '>'
  #[contextual] shl '<<'
  #[contextual] shr '>>'
  thin_arrow '->'
  eq '='
  semi ';'
  colon ':'
  coloncolon '::'
  comma ','
  dot '.'

  star '*'
  slash '/'
  percent '%'
  plus '+'
  minus '-'
  ampersand '&'
  pipe '|'
  underscore '_'

  ident r"\p{XID_Start}\w*"
  number r"\d+"
}

pub rule file { mod_contents }

rule mod_contents {
  <rep <with_skip mod_form_first mod_form>>
}


rule mod_form_first { 
  'pub' | 'extern'
| 'fn' | 'struct' | 'union' | 'enum' | 'use' | 'mod' | 'impl' | 'type'
}

rule mod_form { 
  use_decl | extern_crate_decl | fn_def | struct_def | enum_def | mod_def 
| impl_def | type_def
}

pub rule use_decl {
  <opt visibility> 'use' <commit> { 
    mod_path {alias | <opt {'::' use_spec}>}
  | <opt '::'> use_spec 
  } ';'
}

pub rule use_spec {
  '*'
| <block <comma_list use_spec_entry>> 
}

pub rule use_spec_entry {
  ident <commit> <opt alias>
}

pub rule extern_crate_decl {
  'extern' 'crate' <commit> ident <opt alias> ';'
}

pub rule fn_def {
  <opt visibility> 'fn' <commit> ident
  <opt type_parameters>
  value_parameters
  <opt {'->' type_reference}>
  block_expr
}

rule value_parameters {
  <in_parens {<opt self_parameter> <comma_list value_param>}>
}

pub rule value_param {
  pattern ':' type_reference
}

pub rule self_parameter {
  <opt '&'> 'self' <commit> {',' | <eof>}
}


pub rule struct_def {
  <opt visibility> 
  {'struct' | 'union'} <commit> 
  ident <opt type_parameters> {
    <block <comma_list struct_field>>
  | ';'
  | <in_parens <comma_list tuple_field>>';'
  }
}

pub rule struct_field {
  <opt visibility> ident <commit> ':' type_reference
}

pub rule tuple_field {
  <opt visibility> type_reference
}

pub rule enum_def {
  <opt visibility> 'enum' <commit> ident
  <block <comma_list enum_variant>>
}

pub rule enum_variant {
  ident <commit> <opt {
    '=' expr
  | <in_parens <comma_list tuple_field>>
  | <block <comma_list struct_field>>
  }>
}

pub rule mod_def {
  <opt visibility> 'mod' <commit> ident {
    ';'
  | <block mod_contents>
  }
}

pub rule impl_def {
  'impl' <commit> ident 
  <block <rep <with_skip impl_form_first impl_form>>>
}

rule impl_form {
  fn_def | type_def
}

rule impl_form_first {
  'pub' | 'fn' | 'type'
}

pub rule type_def {
  <opt visibility> 'type' <commit> 
  ident <opt type_parameters>
  <opt {'=' type_reference}>
  ';'
}


pub rule type_parameters {
  <in_angles <comma_list type_parameter>>
}

pub rule type_parameter {
  ident
}

pub rule visibility {
  'pub'
}

rule mod_path { path }
rule type_path { <enter 'type_path' path> }
rule expr_path { <enter 'expr_path' path> }

#[pratt]
pub rule path {
  unqualified_path | qualified_path
}

#[atom, type(path)]
pub rule unqualified_path {
  <opt '::'> path_segment
}

#[postfix, type(path)]
pub rule qualified_path {
  path {'::' path_segment}
}

rule path_segment {
  { ident | 'self' | 'super' } <opt type_arguments>
}

pub rule type_arguments {
  { <is_in 'type_path'> | <is_in 'expr_path'> '::' }
  <in_angles <comma_list type_reference>> 
}


pub rule alias { 'as' ident }

pub rule type_reference {
  type_path | '&' type_reference
}

pub rule pattern { 
  ident | '_'
}

#[pratt]
pub rule expr { 
  literal | struct_literal | path_expr | paren_expr
| block_expr | if_expr
| call_expr | field_expr
| reference_expr | dereference_expr | negation_expr
| product_expr | sum_expr 
| bit_shift
| bit_and | bit_or
}

rule prev_is_block {
  <prev_is if_expr block_expr>
}

rule without_restrictions(p) {
  <exit 'condition' <exit 'stmt' p>>
}

#[atom]
pub rule literal {
  number
}

#[atom]
pub rule struct_literal {
  <not <is_in 'condition'>>
  expr_path <block <comma_list struct_literal_field>>
}

pub rule struct_literal_field {
  ident <commit> ':' expr
}

#[atom]
pub rule paren_expr {
  '(' <without_restrictions expr> ')'
}

#[atom]
pub rule path_expr {
  expr_path
}

#[atom]
pub rule block_expr {
  <without_restrictions
    <block {<rep block_form> <opt expr>}>
  >
}

rule block_form {
  let_stmt | expr_stmt | empty_stmt
}

pub rule let_stmt {
  'let' <commit> pattern '=' expr ';'
}

pub rule empty_stmt { ';' }

pub rule expr_stmt {
  <enter 'stmt'
    {expr {prev_is_block <not <eof>> | ';'}}
  >
}

#[atom]
pub rule if_expr {
  'if' <commit> <enter 'condition' expr> 
    block_expr 
    <opt {'else' block_expr}>
}

#[postfix]
pub rule call_expr {
  expr <without_restrictions
    <in_parens <comma_list value_argument>>>
}

#[postfix]
pub rule field_expr {
  expr {'.' ident}
}


pub rule value_argument {
  expr
}

#[prefix]
pub rule reference_expr { '&' expr }

#[prefix]
pub rule dereference_expr { '*' expr }

#[prefix]
pub rule negation_expr { '-' expr }

#[bin(5)]
pub rule product_expr {
  expr <binop {'*' | '/' | '%'}> expr
}

#[bin(4)]
pub rule sum_expr {
  expr <binop {'+' | '-'}> expr
}

#[bin(3)]
pub rule bit_shift {
  expr <binop {'<<' | '>>'}> expr
}

rule binop(op) {
  <is_in 'stmt'> <not prev_is_block> op
| <not <is_in 'stmt'>> op
}

#[bin(2)]
pub rule bit_and {
  expr <binop '&'> expr
}

#[bin(1)]
pub rule bit_or {
  expr <binop '|'> expr
}


rule comma_list(el) {
  <rep {el <commit> {<eof> | ','}}>
}

rule block(p)     { <balanced_layer '{' '}' p> }
rule in_parens(p) { <balanced_layer '(' ')' p> }
rule in_angles(p) { <balanced_layer '<' '>' p> }

rule balanced_layer(bra, ket, contents) {
  bra <commit> 
    <layer <balanced bra ket> contents> 
  ket
}

rule balanced(bra, ket) {
  <rep {
    bra <commit> <balanced bra ket> ket
  | {<not ket> <any>}
  }>
}
